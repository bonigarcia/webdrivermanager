= WebDriverManager
Boni García

== Motivation
https://seleniumhq.github.io/docs/site/en/webdriver/[Selenium WebDriver] is a library that allows controlling web browsers programmatically. It provides a cross-browser API that can be used to drive web browsers (e.g., Chrome, Edge, or Firefox, among others) using different programming languages (e.g., Java, JavaScript, Python, C#, or Ruby). The primary use of Selenium WebDriver is implementing automated tests for web applications.

Selenium WebDriver carries out the automation using the native support of each browser. For this reason, we need to place a binary file called *driver* between the test using the Selenium WebDriver API and the browser to be controlled. Examples of drivers for major web browsers nowadays are https://chromedriver.chromium.org/[chromedriver] (for Chrome), https://github.com/mozilla/geckodriver/[geckodriver] (for Firefox), or https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/[msedgedriver] (for Edge). As you can see in the following picture, the communication between the WebDriver API and the driver binary is done using a standard protocol called the (https://www.w3.org/TR/webdriver/)[W3C WebDriver specification] (formerly the so-called _JSON Wire Protocol_). Then, the communication between the driver and the browser is done using the native capabilities of each browser.

[[webdriver_arch]]
[.thumb]
.Selenium WebDriver Architecture
image::selenium-webdriver-architecture.png[scaledwidth=100%]

From a practical point of view, we need to carry out a _driver management process_ to use Selenium WebDriver. This process consists on:

1. Download. Drivers are platform-specific binary files. To download the proper driver, we have to identify the driver type we need (e.g., chromedriver if we want to use Chrome), the operating system (typically, Windows, Linux, or Mac OS), the architecture (typically, 32 or 64 bits), and very important, the driver version. Concerning the version, each driver release is usually compatible with a given browser version(s). For this reason, we need to discover the correct driver version for a specific browser release (typically reading the driver documentation or release notes).
2. Setup. Once we have downloaded the driver to our computer, we need to provide a way to locate this driver from our Selenium WebDriver tests. In Java, this setup can be done in two different ways. First, we can add the driver location to our +PATH+ environmental variable. Second, we can use _Java system properties_ to export the driver path. Each driver path should be identified using a given system property, as follows:
+
[source,java]
----
System.setProperty("webdriver.chrome.driver", "/path/to/chromedriver");
System.setProperty("webdriver.gecko.driver", "/path/to/geckodriver");
System.setProperty("webdriver.edge.driver", "/path/to/msedgedriver");
System.setProperty("webdriver.opera.driver", "/path/to/operadriver");
System.setProperty("webdriver.ie.driver", "C:/path/to/IEDriverServer.exe");
----
3. Maintenance. Last but not least, we need to warranty the compatibility between driver and browser in time. This step is relevant since modern browsers automatically upgrade themselves (i.e., they are _evergreen_ browsers), and for this reason, the compatibility driver-browser is not warranted in the long run. For instance, when a WebDriver test using Chrome faces a driver incompatibility, it reports the following error message: "_this version of chromedriver only supports chrome version N_." As you can see in https://stackoverflow.com/search?q=this+version+of+chromedriver+only+supports+Chrome+version[StackOverflow], this is a recurrent problem for manually managed drivers (chromedriver in this case).

https://github.com/bonigarcia/webdrivermanager[WebDriverManager] is an open-source Java library that carries out this <<driver-management,driver management process in a fully automated manner>>. In addition, as of version 5, WebDriverManager provides other relevant features, such as the ability to <<browser-finder,discover if a browser is installed in the system>>, <<webdriver-builder,building WebDriver objects>> (such as `ChromeDriver`, `FirefoxDriver`, etc.), and the capability to run <<browsers-in-docker,browsers in Docker containers>> containers seamlessly.

== Setup
WebDriverManager is primarily used as a Java dependency (although <<other-usages,other usages>> are also possible). We typically use a _build tool_ (such as https://maven.apache.org/[Maven] or https://gradle.org/[Gradle]) to resolve the WebDriverManager dependency. In Maven, it can be done as follows (notice that it is declared using the `test` scope, since it is typically used in tests clasess):

[source,xml]
<dependency>
    <groupId>io.github.bonigarcia</groupId>
    <artifactId>webdrivermanager</artifactId>
    <version>5.0.0</version>
    <scope>test</scope>
</dependency>

In the case of a Gradle project, we can declare WebDriverManager as follows (again, for tests):

[source,json]
dependencies {
    testImplementation("io.github.bonigarcia:webdrivermanager:5.0.0")
}

== Features
WebDriverManager provides a fluent API available using the class `WebDriverManager` (package `io.github.bonigarcia.wdm`). This class provides a group of static methods that allow creating _managers_, i.e., objects devoted to providing automated driver management and other features.

=== Driver Management
The primary use of WebDriverManager is the automation of driver management. For using this feature, you need to select a given manager in the WebDriverMager API (e.g., `chromedriver()` for Chrome) and invoke the method `setup()`. The following example shows a test case using https://junit.org/junit5/[JUnit 5], Selenium WebDriver, WebDriverManager, and https://joel-costigliola.github.io/assertj/[AssertJ] (for fluent assertions). In this test, we invoke WebDriverManager in the setup method for all tests (`@BeforeAll`). This way, the required driver (chromedriver in this case) will be available for all the WebDriver tests using Chrome in this class.

[source,java]
----
include::../../test/java/io/github/bonigarcia/wdm/test/chrome/ChromeTest.java[tags=snippet-in-doc,indent=0]
----

WebDriverManager provides a set _managers_ for Chrome, Firefox, Edge, Opera, Chromium, and Internet Explorer. The basic use of these managers is the following:

[source,java]
----
WebDriverManager.chromedriver().setup();
WebDriverManager.firefoxdriver().setup();
WebDriverManager.edgedriver().setup();
WebDriverManager.operadriver().setup();
WebDriverManager.chromiumdriver().setup()
WebDriverManager.iedriver().setup();
----

As of version 5, WebDriverManager also provides a manager for Safari (called `safaridriver()`). The case of the Safari browser is particular since this browser does not require to manage its driver to work with Selenium WebDriver (in other words, the Safari driver is built-in within the browser). Nevertheless, WebDriverManager provides this manager to be used in the WebDriver builder (especially with <<browsers-in-docker,Docker>>).

==== Resolution Algorithm
WebDriverManager executes a _resolution algorithm_ when calling to `setup()` in a given manager. You can find all the internal details of this algorithm in the paper https://link.springer.com/article/10.1007/s10664-021-09975-3[Automated driver management for Selenium WebDriver], published in the Springer Journal of Empirical Software Engineering. The most relevant parts of this algorithm are the following:

1. WebDriverManager tries to find the browser version. To this aim, WebDriverManager uses internally a knowledge database called https://github.com/bonigarcia/webdrivermanager/blob/master/src/main/resources/commands.properties[commands database]. This database is a collection of shell commands used to discover the version of a given browser in the different operating systems (e.g., `google-chrome --version` for Chrome in Linux).
2. Using the browser version, it tries to find the proper driver version.
This process is different for each browser. In Chrome and Edge, their respective drivers (chromedriver and msedgedriver) maintainers also publish resources to identify the suitable driver version for a given major browser release. For instance, to find out the version of chromedriver required for Chrome 89, we need to read the following https://chromedriver.storage.googleapis.com/LATEST_RELEASE_89[file]. Unfortunately, this information is not available in other browsers (e.g., Firefox and Opera) or older versions of Chrome and Firefox. For this reason, WebDriverManager uses another knowledge database called https://github.com/bonigarcia/webdrivermanager/blob/master/src/main/resources/versions.properties[versions database]. This database maps the browser releases with the known compatible driver versions.
3. Once the driver version is discovered, WebDriverManager downloads this driver to a local cache (located at `~/.cache/selenium` by default). These drivers are reused in subsequent calls.
4. Finally, WebDriverManager exports the driver path using Java system properties (e.g., `webdriver.chrome.driver` in the case of the Chrome manager).

This process automated the first two stages of the driver management previously introduced, i.e., download and setup. To support the third stage (i.e., maintenance), WebDriverManager implements _resolution cache_. This cache (called by default `resolution.properties` and stored in the root of the driver cache) is a file that stores the relationship between the resolved driver and browser versions. This relationship is valid during a given _time-to-live_ (TTL). The default value for this TTL is 1 hour for browsers and 1 day for drivers. In other words, the discovered browser version is valid for 1 hour, and the driver version is correct for 1 day. This mechanism improves the performance dramatically since the second (and following) calls to the resolution algorithm for the same browser are resolved using local resources (i.e., without using the shell nor requesting external servers).

==== Generic Manager
WebDriverManager provides a _generic manager_, i.e., a manager that can be parameterized to act as a specific manager (for Chrome, Firefox, etc.). You can create a manager using this feature using the method `getInstance()` of the WebDriverManager API. The method can be invoked using the following options:

* `getInstance(Class<? extends WebDriver> webDriverClass)`: Where `webDriverClass` is a class of the Selniun WebDriver standard hierarchy, such as `ChromeDriver.class`, `FirefoxDriver.class`, etc.
* `getInstance(DriverManagerType driverManagerType)`: Where `driverManagerType` is an https://github.com/bonigarcia/webdrivermanager/blob/master/src/main/java/io/github/bonigarcia/wdm/config/DriverManagerType.java[enumeration] provided by WebDriverManager to identify the available managers.
* `getInstance(String browserName)`: Where `browserName` is the usual browser name as `String` (e.g., `"Chrome"`, `"Firefox"`, `"Edge"`, etc.).
* `getInstance()`: If no parameter is specific, then the configuration key `wdm.defaultBrowser` is used to select the manager (Chrome by default). See the <<configuration,configuration>> section for further information about the configuration capabilities of WebDriverManager.

The following example shows a https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests[JUnit 5 parameterized test] in which the test is repeated twice (using the classes `ChromeDriver.class` and `FirefoxDriver.class` as test parameters). As you can see, WebDriverManager instantiates the proper manager using this parameter.

[source,java]
----
include::../../test/java/io/github/bonigarcia/wdm/test/generic/GenericTest.java[tags=snippet-in-doc,indent=0]
----

=== Browser Finder
As of version 5, WebDriverManager allows detecting if a given browser is installed or not in the local system. To this aim, each manager provides the method `getBrowserPath()`. This method returns an `Optional<Path>`, which is empty if a given browser is not installed in the system, or the browser path (within the optional object) if it is detected. 

The following example shows an example using this feature.
In this test, the optional browser path is used to disable conditionally (i.e., skip) the test using an https://assertj.github.io/doc/#assertj-core-assumptions[AssertJ assumption] (although other built-in assumptions available in JUnit 5 or other unit testing frameworks are also possible). All in all, this test should be executed in a Mac OS system (which should have Safari out of the box), but it should be skipped in any other machine.

[source,java]
----
include::../../test/java/io/github/bonigarcia/wdm/test/safari/SafariTest.java[tags=snippet-in-doc,indent=0]
----

NOTE: Internally, WebDriverManager uses the content of the https://github.com/bonigarcia/webdrivermanager/blob/master/src/main/resources/commands.properties[commands database] to detect the possible browser paths in different operating systems.

=== WebDriver Builder
As of version 5, WebDriverManager allows instantiating `WebDriver` objects (e.g. `ChromeDriver`, `FirefoxDriver`, etc.) using the WebDriverManager API. This feature is available using the method `create()` of each manager. The following example shows a test using this feature. Notice that the WebDriverManager call to the `setup()` method is not required when using this feature since the driver management is done internally by WebDriverManager. To complement this feature, WebDriverManager provides the method `quit()` to close the created `WebDriver` instances gracefully.

[source,java]
----
include::../../test/java/io/github/bonigarcia/wdm/test/create/ChromeCreateTest.java[tags=snippet-in-doc,indent=0]
----

The WebDriverManager API provides different methods to enhance the creation of `WebDriver` objects, such as:

* Method `capabilities()`: To specify WebDriver `Capabilities` (see https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/create/ChromeCapabilitiesCreateTest.java[example]).
* Method `remoteAddress()`: To specify the remote URL in the `RemoteWebDriver` instance (typically when using a Selenium Server). See https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/create/ChromeRemoteTest.java[example].
* Integer parameter in the method `create()`. This option is used to create a list of `WebDriver` objects instead of a single instance. See https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/create/ChromeListCreateTest.java[example].

=== Browsers in Docker
Another relevant new feature available in WebDriverManager 5 is the ability to create browsers in https://www.docker.com/[Docker] containers out of the box. The requirement to use this feature is to have installed a https://docs.docker.com/engine/[Docker Engine] in the machine running the tests. To use it, we need to invoke the method `browserInDocker()` in conjunction with `create()` of a given manager. This way, WebDriverManager pulls the image from https://hub.docker.com/[Docker Hub], starts the container, and instantiates the `WebDriver` object to use it. The following test shows a simple example using Chrome in Docker:

[source,java]
----
include::../../test/java/io/github/bonigarcia/wdm/test/docker/DockerChromeTest.java[tags=snippet-in-doc,indent=0]
----

NOTE: When using browsers in Docker containers, the call to the method `quit()` of the WebDriverManager API allows the disposal of the browser container(s).

The used Docker images by WebDriverManager have been created and maintained by https://aerokube.com/images/latest/[Aerokube]. Therefore, the available browsers to be executed as Docker containers in WebDriverManager are: Chrome (like the previous example), Firefox (see https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/docker/DockerFirefoxTest.java[example]), Edge (see https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/docker/DockerEdgeTest.java[example]), Opera (see https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/docker/DockerOperaTest.java[example]), and Safari (see https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/docker/DockerSafariTest.java[example]).

The case of Safari is particular since a real Safari browser can only be executed under a Mac OS machine. This way, the _Safari_ Docker containers use the https://webkit.org/[WebKit engine]. This engine is the same used in browser containers, and therefore, from a functional point of view, both browsers (a real Safari and this Docker image) should behave in the same way.

In addition to these browsers, there is one more alternative: Chrome Mobile (i.e., Chrome on an Android device). To use this browser, you need to invoke the method `browserInDockerAndroid()` of a Chrome manager, just like in this https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/docker/DockerChromeMobileTest.java[example]. Notice that a hardware server or virtual machine with nested virtualization support is required to run Chrome Mobile images.

==== Browser Versions
A significant aspect of the browser containers presented so far is that WebDriverManager connects to Docker Hub to discover the latest available release when the browser version is not specified (like the examples explained before). This way, the _dockerized_ browsers of tests handled by WebDriverManager are auto-maintained, in the sense that these tests use the latest version available without any further effort.

Nevertheless, we can force to use a given browser version in Docker using the method `browserVersion()` of the WebDriverManager API. This method accepts a `String` parameter specifying the version. This version can be fixed (e.g., `91.0`), and it also accepts the following wildcards:

* `"latest"` : To specify the latest version explicitly (default option).
* `"latest-N"` : Where `N` is an integer value to be subtracted from the current stable version. For example, if we specify `latest-1` (i.e., _latest version minus one_), the previous version to the stable release will be used (see an example https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/docker/DockerChromeVersionsTest.java[here]).
* `"beta"`: To use the beta version. This version is only available for Chrome and Firefox, thanks to the Docker images maintained by https://hub.docker.com/r/twilio/selenoid/[Twilio] (a fork of the Aerokube images for the beta and development versions of Chrome and Firefox).
* `"dev"`: To use the development version (again, for Chrome and Firefox).

The following example shows a test using Chrome beta in Docker (see a similar example using Firefox dev https://github.com/bonigarcia/webdrivermanager/blob/master/src/test/java/io/github/bonigarcia/wdm/test/docker/DockerFirefoxDevTest.java[here]).

[source,java]
----
include::../../test/java/io/github/bonigarcia/wdm/test/docker/DockerChromeBetaTest.java[tags=snippet-in-doc,indent=0]
----

==== Remote Desktop
A possible inconvenience of using browsers in Docker is that we cannot see what is happening inside the container by default. To improve this situation, WebDriverManager allows connecting to the remote desktop session of a browser simply invoking the method `enableVnc()` of a dockerized browser. When using this option, two different technologies are used internally:

* Virtual Network Computing (VNC), a graphical desktop sharing system. In WebDriverManager, a VNC server is started in the browser container.
* https://novnc.com/[noVNC], a open-source web-based VNC client. In WebDriverManager, a custom https://github.com/bonigarcia/novnc[noVNC Docker image] is used to connect through noVNC.

The following example shows a test that enables this feature. WebDriverManager writes the noVNC URL in the `INFO` trace logs. In addition, as shown in this example, this URL can be found by invoking the method `getDockerNoVncUrl()`. We can use this URL to inspect and interact with the browser during the test execution (as shown in the following picture).

[source,java]
----
include::../../test/java/io/github/bonigarcia/wdm/test/docker/DockerChromeVncTest.java[tags=snippet-in-doc,indent=0]
----

[[vnc]]
[.thumb]
.Example of noVNC session using Chrome in Docker
image::wdm-vnc.png[scaledwidth=100%]

==== Recordings
The following related feature is the recording of the remote session of a dockerized browser. To enable it, we need to invoke the method `enableRecording()` in WebDriverManager. Internally, WebDriverManager starts another Docker container using https://ffmpeg.org/[FFmpeg] to record the browser session. At the end of the test, we can find the recording in MP4, by default, in the same folder of the project root. The following example shows a simple using this feature.

[source,java]
----
include::../../test/java/io/github/bonigarcia/wdm/test/docker/DockerChromeRecordingTest.java[tags=snippet-in-doc,indent=0]
----

== Other Usages
In addition to as a regular Java dependency, WebDriverManager can be used in other ambits. This section summarizes these usages.

=== WDM CLI
WebDriverManager can be used interactively from the Command Line Interface (CLI), i.e., the shell. There are three different ways to use WebDriverManager as a CLI tool:

1. Using the WebDriverManager _fat-JAR_ (i.e., WebDriverManager with all its dependencies in a single executable JAR file). This JAR file is released on GitHub with every new version of WebDriverManager. You can download the latest version from https://github.com/bonigarcia/webdrivermanager/releases/download/webdrivermanager-5.0.0/webdrivermanager-5.0.0-fat.jar[here]. Once you get this file, you  need to use the following command in the shell (where `<args>` are the accepted arguments, explained below):
+
[source,shell]
----
java -jar webdrivermanager-5.0.0-fat.jar <args>
----
2. Using the source code. WebDriverManager is hosted on https://github.com/bonigarcia/webdrivermanager[GitHub]. We can use Maven to manage its Java source code. For example, to run the CLI mode using Maven and the source code, we need to invoke the following Maven command in the shell from the project root:
+
[source,shell]
----
mvn exec:java -Dexec.args="<args>"
----
3. Using the WebDriverManager Docker container. Each new release of WebDriverManager is pushed to https://hub.docker.com/r/bonigarcia/webdrivermanager[Docker Hub] as a container based on https://hub.docker.com/_/openjdk[OpenJDK] plus the WebDriverManager fat-JAR. The default command to run the WebDriverManager Docker container is described below.        
+
[source,shell]
----
docker run --rm -e ARGS="<args>" bonigarcia/webdrivermanager:5.0.0
----

WebDriverManager CLI can be used for three different purposes. We can see these options launching the CLI with empty or invalid arguments (`<args>` in the commands before). In this case, the output of WebDriverManager CLI is the following:

[source,shell]
----
[ERROR] The valid arguments for WebDriverManager CLI are:
[ERROR] 1. For resolving drivers locally:
[ERROR]     resolveDriverFor=browserName <driverVersion>
[ERROR] (where browserName is: chrome|edge|firefox|opera|chromium|iexplorer)
[ERROR]
[ERROR] 2. For running a browser in a Docker (and use it trough noVNC):
[ERROR]     runInDocker=browserName <browserVersion>
[ERROR] (where browserName=chrome|edge|firefox|opera|safari|chrome-mobile)
[ERROR]
[ERROR] 3. For starting WebDriverManager Server:
[ERROR]     server <port>
[ERROR] (where the default port is 4444)
----

[discrete]
==== Option 1: Driver Resolver
WebDriverManager CLI can be used to resolve drivers (e.g., chromedriver, geckodriver) applying the usual <<resolution-algorithm,resolution algorithm>> from the shell. This feature can be interesting if we want to download drivers outside a Java program. To use this option, we need to invoke WebDriverManager CLI using the following arguments (supposing we need to resolve chromedriver):

* Fat-JAR:
[source,shell]
----
java -jar webdrivermanager-5.0.0-fat.jar resolveDriverFor=chrome
----
* Source code:
[source,shell]
----
mvn exec:java -Dexec.args="resolveDriverFor=chrome"
----
* Docker container:
[source,shell]
----
docker run --rm -v ${PWD}:/wdm -e ARGS="resolveDriverFor=chrome" bonigarcia/webdrivermanager:5.0.0
----

[discrete]
==== Option 2: Browsers in Docker
WebDriverManager CLI can be used to execute browsers in Docker containers and interact with them using noVNC. This feature can be interesting for _exploratory testing_ for web applications using different types and versions of web browsers. To use this option, the arguments we need to use are the following (supposing we want to use Chrome):

* Fat-JAR:
[source,shell]
----
java -jar webdrivermanager-5.0.0-fat.jar runInDocker=chrome
----
* Source code:
[source,shell]
----
mvn exec:java -Dexec.args="runInDocker=chrome"
----
* Docker container:
[source,shell]
----
docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock -e ARGS="runInDocker=chrome 91" bonigarcia/webdrivermanager:5.0.0
----

WARNING: There is an https://bugs.chromium.org/p/chromedriver/issues/detail?id=3857[open issue] with Chrome 92+ and Docker at the time of this writing. For this reason, the previous Docker container command uses Chrome 91. For further information, see <<known-issues, known issues>>.

[discrete]
==== Option 3: Server
Finally, WebDriverManager CLI allows starting the WebDriverManager Server, as follows (see <<wdm-server,next section>> for more details about it):

* Fat-JAR:
[source,shell]
----
java -jar webdrivermanager-5.0.0-fat.jar server
----
* Source code:
[source,shell]
----
mvn exec:java -Dexec.args="server"
----
* Docker container:
[source,shell]
----
docker run --rm -p 4444:4444 -v /var/run/docker.sock:/var/run/docker.sock bonigarcia/webdrivermanager:5.0.0
----

=== WDM Server
The WebDriverManager Server is based on HTTP and offers two types of services. First, it can be used to resolve drivers (chromedriver, geckodriver, etc.). The WebDriverManager Server exposes a REST-like API to this aim. WebDriverManager Server sends the resolved driver as an HTTP attachment in the response. The endpoints provided by this API are the following (supposing that WebDriverManager is running the localhost in its default port, i.e., 4444):

* http://localhost:4444/chromedriver[http://localhost:4444/chromedriver]: To resolve chromedriver.
* http://localhost:4444/firefoxdriver[http://localhost:4444/firefoxdriver]: To resolve geckodriver.
* http://localhost:4444/edgedriver[http://localhost:4444/edgedriver]: To resolve msedgedriver.
* http://localhost:4444/operadriver[http://localhost:4444/operadriver]: To resolve geckodriver.
* http://localhost:4444/iedriver[http://localhost:4444/iedriver]: To resolve geckodriver.

Second, the WebDriverManager Server acts as a regular Selenium Server (i.e., a _hub_ in the classical https://www.selenium.dev/documentation/en/grid/[Selenium Grid] architecture). This feature can be used to create remote `WebDriver instances using the WebDriverManager Server (even for different language bindings than Java). The following example shows a Node.js test using Selenium WebDriver and WebDriverManager Server (notice that by default, the WebDriverManager Server URL does not require any path, i.e., http://localhost:4444/[http://localhost:4444/]):

[source,javascript]
----
var webdriver = require("selenium-webdriver");

async function wdmServerTest() {
    var wdmServerUrl = "http://localhost:4444/";
    var capabilities = {
        browserName : "chrome",
        version: "91.0"
    };

    try {
        var driver = await new webdriver.Builder().usingServer(wdmServerUrl)
                .withCapabilities(capabilities).build();

        var sutUrl = "https://bonigarcia.org/webdrivermanager/";
        await driver.get(sutUrl);

        await driver.getTitle().then(function(title) {
            console.log("The title of " + sutUrl + " is '" + title + "'")
        });

    } catch (err) {
        console.error("Something went wrong!\n", err.stack);

    } finally {
        if (driver) {
            driver.quit();
        }
    }
}

wdmServerTest();
----

=== WDM Agent
WebDriverManager can also be used as _Java Agent_. In this case, and using the JVM instrumentation API, WebDriverManager intercepts calls to applications running on the JVM and modifies their bytecode. In particular, the WebDriverManager Agent uses this technique to check the objects being created in the JVM. Before Selenium WebDriver objects are instantiated (`ChromeDriver`, `FirefoxDriver`, etc.), the required manager is used to resolve its driver (chromedriver, geckodriver, etc.). Thanks to this approach, we can get rid of the WebDriverManager call (e.g. `WebDriverManager.chromedriver.setup();`) from our test, for example:

[source,java]
----
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;

class ChromeAgentTest {

    WebDriver driver;

    @BeforeEach
    void setupTest() {
        driver = new ChromeDriver();
    }

    @AfterEach
    void teardown() {
        if (driver != null) {
            driver.quit();
        }
    }

    @Test
    void test() {
        // Test logic
    }

}
----

To configure the WebDriverManager Agent, we need to specify the path of the WebDriverManager https://github.com/bonigarcia/webdrivermanager/releases/download/webdrivermanager-5.0.0/webdrivermanager-5.0.0-fat.jar[fat-JAR] using the JVM flag `-javaagent:/path/to/webdrivermanager-5.0.0-fat.jar`. Alternatively, it can be done using Maven (see a complete project example https://github.com/bonigarcia/wdm-agent-example/[here]).

=== Selenium-Jupiter
WebDriverManager is the heart of the project https://github.com/bonigarcia/selenium-jupiter[Selenium-Jupiter], an open-source JUnit 5 extension for Selenium WebDriver. Selenium-Jupiter uses the programming and extension model provided by JUnit 5 (called https://junit.org/junit5/docs/current/user-guide/[Jupiter]) together with WebDriverManager to create tests with reduced boilerplate code. For instance, thanks to the Jupiter feature for parameter resolution, we can declare a type of the `WebDriver` hierarchy (e.g., `ChromeDriver`) as a test parameter. Internally, Selenium-Jupiter resolves its driver and creates the instance before tests, and then, the browser is gracefully closed at the end of the test. For example:

[source,java]
----
import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.openqa.selenium.chrome.ChromeDriver;

import io.github.bonigarcia.seljup.SeleniumJupiter;

@ExtendWith(SeleniumJupiter.class)
class ChromeJupiterTest {

    @Test
    void test(ChromeDriver driver) {
        driver.get("https://bonigarcia.org/selenium-jupiter/");
        assertThat(driver.getTitle()).contains("Selenium-Jupiter");
    }

}
----

Selenium-Jupiter provides more different features, such as seamless integration with Docker, test templates (for cross-browser testing), conditional test execution (depending on the availability of browsers), conditional screenshots, and recordings (when tests fail), and more. For further details, read the https://bonigarcia.org/selenium-jupiter/[Selenium-Jupiter documentation].

== Examples
The following repositories contain different examples using WebDriverManager:

* https://github.com/bonigarcia/webdrivermanager-basic[WebDriverManager Basic]: A simple project using JUnit 5, Selenium WebDriver, and WebDriverManager.
* https://github.com/bonigarcia/webdrivermanager-examples[WebDriverManager Examples]: Different examples with JUnit 5, Selenium WebDriver, and WebDriverManager.
* https://github.com/bonigarcia/webdrivermanager-spring-boot[WebDriverManager Spring-Boot]: Another simple project using Spring-Boot, JUnit 5, Selenium WebDriver, and WebDriverManager.
* https://github.com/bonigarcia/wdm-agent-example[WebDriverManager Agent Example]: Maven project using WebDriverManager as Agent.
* https://github.com/bonigarcia/selenium-jupiter-examples[Selenium-Jupiter Examples]: Examples using JUnit 5 and <<selenium-jupiter,Selenium-Jupiter>>.

== Configuration
To do.

== Known issues
[discrete]
==== HTTP response code 403
Some of the drivers (e.g., geckodriver or operadriver) are hosted on GitHub. When external clients (like WebDriverManager) makes many consecutive requests to GitHub, and due to its traffic rate limit, it eventually responds with an HTTP 403 error (_forbidden_), as follows:

[source]
----
io.github.bonigarcia.wdm.config.WebDriverManagerException: Error HTTP 403 executing https://api.github.com/repos/mozilla/geckodriver/releases
    at io.github.bonigarcia.wdm.online.HttpClient.execute(HttpClient.java:172)
    at io.github.bonigarcia.wdm.WebDriverManager.openGitHubConnection(WebDriverManager.java:1266)
    at io.github.bonigarcia.wdm.WebDriverManager.getDriversFromGitHub(WebDriverManager.java:1280)
    at io.github.bonigarcia.wdm.managers.FirefoxDriverManager.getDriverUrls(FirefoxDriverManager.java:95)
    at io.github.bonigarcia.wdm.WebDriverManager.createUrlHandler(WebDriverManager.java:1111)
    at io.github.bonigarcia.wdm.WebDriverManager.download(WebDriverManager.java:959)
    at io.github.bonigarcia.wdm.WebDriverManager.manage(WebDriverManager.java:877)
    at io.github.bonigarcia.wdm.WebDriverManager.fallback(WebDriverManager.java:1106)
    at io.github.bonigarcia.wdm.WebDriverManager.handleException(WebDriverManager.java:1083)
    at io.github.bonigarcia.wdm.WebDriverManager.manage(WebDriverManager.java:883)
    at io.github.bonigarcia.wdm.WebDriverManager.setup(WebDriverManager.java:328)
----

To avoid this problem, WebDriverManager can make authenticated requests using a https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token[personal access token]. See the <<configuration,configuration>> section to discover how to set up this token in WebDriverManager.

[discrete]
==== Testing localhost
A typical case in web development is testing a web application deployed in the local host. In this case, and when using browsers in Docker containers, we need to know that the address `localhost` inside a Docker container is not the host's address but the container address. To solve this problem, we can take different approaches. In Linux, we can use the gateway address for inter-container communication. This address is usually `172.17.0.1`, and can be discovered as follows:

[source,shell]
----
$ ip addr show docker0
4: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:b4:83:10:c8 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
----

When the host is Mac OS or Windows, we can use the DNS name `host.docker.internal`, which will be resolved to the internal IP address used by the host.

[discrete]
==== Chrome 92+ in Docker
There is an https://bugs.chromium.org/p/chromedriver/issues/detail?id=3857[open issue] with Chrome 92+ and Docker at the time of this writing. The problem can be solved to some extent by using the argument `--disable-gpu` in Chrome and Edge. This argument already passed to these containers to avoid the issue. Nevertheless, there are still some situations in which it is not possible to fix. For instance, when using https://hub.docker.com/r/bonigarcia/webdrivermanager[WebDriverManager in Docker] in the CLI or Server mode.

== Support
There are several ways to get in touch with WebDriverManager:

* Questions about WebDriverManager are supposed to be discussed in https://stackoverflow.com/questions/tagged/webdrivermanager_java[StackOverflow], using the tag _webdrivermanager_java_.
* Comments, suggestions, and bug-reporting should be made using the https://github.com/bonigarcia/webdrivermanager/issues[GitHub issues].
* If you think WebDriverManager can be enhanced, consider contributing to the project through a  https://github.com/bonigarcia/webdrivermanager/pulls[pull request].

== Contributing
To do.

== Further documentation
To do.

== About
WebDriverManager (Copyright © 2017-2021) is an open-source project created and maintained by https://bonigarcia.org/[Boni García] (https://twitter.com/boni_gg[@boni_gg]), licensed under the terms of https://www.apache.org/licenses/LICENSE-2.0[Apache 2.0 License]. This documentation (also available in link:webdrivermanager.pdf[PDF]) is released under the terms of https://creativecommons.org/licenses/by-nc-sa/2.0/[CC BY-NC-SA 2.0].
